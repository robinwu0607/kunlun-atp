接口函数
========

lib.get_uut()
---------------
此接口函数可以获取连接。通过传入不同的协议以及变量，获取相应连接，连接接收到的日志将打印至网页界面的 **UUT** 窗口。

* 获取DUMMY连接::

    uut = lib.get_uut(protocol="DUMMY")

* 获取串口SERIAL连接::

    uut = lib.get_uut(protocol="SERIAL", serial="COM1", baud=115200)

* 获取SSH连接::

    uut = lib.get_uut(protocol="SSH", host="192.168.2.10", username="admin", password="admin")

* 获取TELNET连接::

    uut = lib.get_uut(protocol="TELNET", host="192.168.2.10", port=2005)

获取连接后，连接实例保存在变量uut中，实例有以下几种使用方法:

1. ``uut.open()`` ：打开连接
2. ``uut.close()`` ：关闭连接
3. ``uut.send()`` : 向连接传递命令行.
4. ``uut.buf`` ：保存最近一条 *uut.send()* 语句发送后，产品回馈的日志。

``send()`` 是传递命令行的唯一方式，使用方法如下::

    uut.send("python\r", expect=">>>", timeout=10)

对此语句的解释：发送命令行 ``python`` ，并带回车符 ``\r`` ，并期望在 ``timeout`` 的10秒钟内，收到字符 ``>>>`` 。
若收到，此语句正常完成，产品反馈的日志将以字符串形式保存在 ``uut.buf`` 中，并执行下一条语句。
若未收到，触发异常，测试结束。

每次 ``uut.send()`` 前会自动清空 ``uut.buf`` , 每次 ``uut.send()`` 完成后，收到的字符自动保存在 ``uut.buf`` 。
本例中 ``uut.send()`` 后，如果使用 ``log.debug(uut.buf)`` 将打印出如下字符::

    python
    Python 3.7.8 (tags/v3.7.8:4b47a5b6ba, Jun 28 2020, 08:53:46) [MSC v.1916 64 bit (AMD64)] on win32
    Type "help", "copyright", "credits" or "license" for more information.
    >>>

当调用 ``lib.get_uut(protocol="SSH")`` 后，可以在其他函数中使用 ``lib.conn.UUT`` 获取连接实例，以便持续使用 ``uut.send()`` 发送指令。

lib.get_ref()
---------------
此接口函数使用方法与 ``lib.get_uut()`` 完全一致。唯一不同点，连接接收到的日志将打印至网页界面的 **REF** 窗口。

lib.ask_question()
------------------
此接口函数提供一个用户交互方法，调用此函数后，网页界面将弹出对话框，用户可以在对话框应答一个问题，并返回答案(字符串).

使用示例：弹出对话框，要求应答一个问题::

    ans = lib.ask_question("请输入序列号SERIAL：", timeout=60 * 3)

答案将保存在 ``ans`` 中。

lib.ask_questions()
------------------
此接口函数提供一个用户交互方法，调用此函数后，网页界面将弹出对话框，用户可以在对话框同时应答多个问题，并返回答案(列表).

使用示例：弹出对话框，要求应答多个问题::

    ans = lib.ask_questions(["请输入序列号SERIAL：", "请输入UUTTYPE：", "请输入员工工号："], timeout=60 * 3)

答案将保存在 ``ans`` 中。

lib.set_display1/2/3()
-----------------------
设置及测试工位上的显示，display1/2/3分别对应工位面板的上/中/下显示。
使用示例::

    lib.set_display1("序列号:12345678")

lib.set_test_name()
---------------
设置当前测试用例, 若此测试项FAIL, 则测试记录自动用此名字作为测试失败项, PASS则不记录。
使用示例::

    lib.set_test_name("run cpu test")

lib.get_container_name()
--------------------------
返回当前的测试工位名字。例：在 ``FT:UUT00`` 上点击开始测试，返回值为字符串 ``FT:UUT00`` 。

lib.add_test_data()
----------------------
在测试过程中，调用此接口函数，登记一次测试记录。
测试完成后，根据测试结果成功或是失败，自动记录一笔 ``P`` （Pass）或是 ``F`` （Fail）::

    lib.add_test_data(sernum=serial, uuttype=uuttype, area="FT")

此接口函数最少需要3个参数， ``sernum`` 为产品条码,  ``uuttype`` 为产品类型,  ``area`` 为测试工站。

lib.get_mode()
---------------
返回当前测试的模式，值为 ``PRODUCT`` 或是 ``DEVELOP`` 。

lib.get_params()
------------------------------
返回 ``hostname.py`` 中相应工站的 ``params`` 的值，是一个字典。
例: 如设置 ``params=dict(host="192.168.1.1", port=2003)``，则返回值为 ``{"host": "192.168.1.1", "port": 2003}`` 。

lib.get_project_name()
-----------------------
返回 ``hostname.py`` 中相应工站的 ``sequencer`` 的第一个值(以 **.** 点号分开)，是一个字符串。
例: 如设置 ``sequencer="demo.main"``, 则返回值为 ``demo`` 。

lib.get_sequencer_definition()
------------------------------
返回 ``sequencer`` 实例，用此实例编排测试序列，测试过程中，可以在 **调试界面** 的 ``STEP`` 窗口查看测试序列流程图。
假设测试代码中定义有如下函数::

    def run_test():
        log.debug("welcome to main sequencer")
        container_name = lib.get_container_name()
        log.debug(container_name)
        return

    def run_test1():
        uut = lib.get_uut(protocol="DUMMY")
        uut.open()  # open the connection
        log.debug("run test1: dir")
        uut.send("dir\r", expect=">", timeout=10)
        time.sleep(1)
        return

    def run_test2():
        uut = lib.conn.UUT
        log.debug("run test2: cd")
        uut.send("cd\r", expect=">", timeout=10)
        return

    def run_test3():
        lib.add_test_data(sernum="1234567890", uuttype="DEMO", area="DEMO")
        log.debug("run test3: finalize set True.")
        return

``sequencer`` 的基本使用示例::

    def main_sequencer():
        seq = lib.get_sequencer_definition("SEQ")
        seq.add_step(run_test, name="RUN TEST")
        seq.add_step(run_test1, name="RUN TEST1")
        seq.add_step(run_test2, name="RUN TEST2")
        seq.add_step(run_test3, name="RUN TEST3")
        return seq

注意：``add_step()`` 后要跟函数或方法的名字，``免小括号()`` 。

``sequencer`` 形式的代码编排，为测试策略的实施提供了便利，以下是当前支持的策略，更多策略持续增加中。

1. 通过设置 ``in_parallel=True`` 可以实施 **平行测试** 策略。

使用示例::

    def main_sequencer():
        seq = lib.get_sequencer_definition()
        seq.add_step(run_test, name="RUN TEST")
        seq.add_step(run_test1, name="RUN TEST1", in_parallel=True)
        seq1 = seq.add_sequencer("SUB SEQUENCER")
        seq1.add_step(run_test2, name="RUN TEST2")
        seq1.add_step(run_test3, name="RUN TEST3")
        seq1.add_step(run_test4, name="RUN TEST4")
        return seq

2. 通过设置 ``continue_on_error=True`` 可以实施 **测试失败不中断** 策略，最终测试仍以失败结束。
若有多个step被施加此策略，最终测试失败项自动选择第一个失败的step。

使用示例::

    # re-define run_test2() function.
    def run_test2():
        uut = lib.conn.UUT
        log.debug("run test2: cd")
        uut.send("cd\r", expect=">", timeout=10)
        raise Exception("run test2 failed")

    def main_sequencer():
        seq = lib.get_sequencer_definition("SEQ")
        seq.add_step(run_test, name="RUN TEST")
        seq.add_step(run_test1, name="RUN TEST1")
        seq.add_step(run_test2, name="RUN TEST2", continue_on_error=True)
        seq.add_step(run_test3, name="RUN TEST3")
        return seq

3. 通过设置 ``finalize=True`` 可以实施 **测试失败后清理** 策略。若 ``run_test2`` 测试失败，会自动运行最后一个step，即 ``run_test3``。
若最后一个step测试失败，则不会再次运行最后一个step。

使用示例::

    def main_sequencer():
        seq = lib.get_sequencer_definition("SEQ", finalize=True)
        seq.add_step(run_test, name="RUN TEST")
        seq.add_step(run_test1, name="RUN TEST1")
        seq.add_step(run_test2, name="RUN TEST2")
        seq.add_step(run_test3, name="RUN TEST3")
        return seq

3. 通过设置 ``loop_on_error=3`` 可以实施 **测试失败后重测** 策略。若 ``run_test2`` 测试失败，会自动重测3次，其中任何一次pass，
此step为pass。

使用示例::

    def main_sequencer():
        seq = lib.get_sequencer_definition("SEQ", finalize=True)
        seq.add_step(run_test, name="RUN TEST")
        seq.add_step(run_test1, name="RUN TEST1")
        seq.add_step(run_test2, name="RUN TEST2", loop_on_error=3)
        seq.add_step(run_test3, name="RUN TEST3")
        return seq

注意：一个step可以实施单一策略，也可以实施组合策略。 优先级 ``loop_on_error`` > ``continue_on_error`` 。
``in_parallel`` 和 ``finalize`` 为独立策略，与其他策略无冲突。

lib.set_sequencer_data()
------------------------
为当前的step增加sequencer数据，sequencer数据可以通过 ``lib.get_sequencer_data()`` 获得。

例如在函数 ``run_test2()`` 中调用此接口函数::

    lib.set_sequencer_data(param1=1234, test=5434, value=2344)

lib.get_sequencer_data()
------------------------
获取sequencer数据，例如在函数 ``run_test3()`` 中调用此接口函数::

    lib.get_sequencer_data()

    # could get below sequencer data.
    [
        {'index': 1, 'name': 'RUN_TEST', 'result': 'PASS', 'time_cost': 0},
        {'index': 2, 'name': 'RUN_TEST1', 'result': 'PASS', 'time_cost': 4},
        {'index': 3, 'name': 'RUN_TEST2', 'result': 'FAIL', 'time_cost': 0, 'param1': 1234, 'test': 5434, 'value': '2344'},
        {'index': 4, 'name': 'RUN_TEST3', 'result': 'PASS', 'time_cost': 0}
    ]

lib.get_xlsx_params()
-----------------------
返回当前项目下的XLSX(Excel)文件中的值, XLSX的命名必须是 ``params.xlsx`` ,
如当前项目为 ``demo``, 则XLSX的路径为 ``demo/params.xlsx`` 。

其内容格式如下:

+---------+----------------------+
| name    | value                |
+=========+======================+
| param1  | 1234                 |
+---------+----------------------+
| param2  | 4567                 |
+---------+----------------------+
| param3  | 8765                 |
+---------+----------------------+

使用示例:

假设XLSX当前的Sheet名为 ``Sheet1`` , 若要获取 ``param2`` 的值,
则调用 ``lib.get_xlsx_params("Sheet1", "param2")``， 即返回字符串 ``4567`` 。

lib.xlsx_measure()
-----------------------
通过XLSX(Excel)文件定义指标数据(指标上限与指标下线), 在接口函数中带入 **实际测量值** , 可自动进行指标检查。 XLSX的命名必须是 ``meas.xlsx`` ,
如当前项目为 ``demo``, 则XLSX的路径为 ``demo/meas.xlsx`` 。

其内容格式如下:

+---------+----------+-----------+
| name    | lower    |   upper   |
+=========+==========+===========+
| meas1   | 20       |    50     |
+---------+----------+-----------+
| meas2   | 40       |    78.9   |
+---------+----------+-----------+
| meas3   | -35      |     35.9  |
+---------+----------+-----------+

使用示例:

假设XLSX当前的Sheet名为 ``Sheet1`` , 待检查的指标名为 ``meas1`` , 实际测量值为 ``30`` 。
调用 ``lib.xlsx_measure("Sheet1", "meas1", 30)``,  XLSX文件中 ``meas1`` 的lower(指标下限)为 ``20`` ,
upper(指标上限)为 ``50`` , 因为 ``20<=30<=50`` , 所以指标检查通过。

若实际测量值为 ``60`` ，则指标检查失败，将触发异常，测试失败。
